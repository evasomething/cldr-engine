import { sortSet, Code, HEADER, NOLINT_MAXLINE } from './util';

type StringMap = { [x: string]: string };
export type MapSet = { [x: string]: Set<string> };

// Partition identifier base character, Greek alpha
const BASE = 0x03b1;

/**
 * Create or update a set stored in a map under the given key.
 */
const mapSet = (map: MapSet, key: string, val: string) => {
  let values = map[key];
  if (values === undefined) {
    values = new Set<string>();
    map[key] = values;
  }
  values.add(val);
};

/**
 * Populate the various structures that make up the partition table.
 *
 * // TODO: may move this into the compiler and load the data
 * directly into the table at runtime.
 */
export const buildPartitions = (data: any) => {
  const { territoryContainment, matchVariables } = data;

  // Sequence for creating partition ids.
  let partitionIdSequence = 0;

  // Get the unique partition id for the given list of variables.
  const getPartitionId = (ids: StringMap, vars: Set<string>) => {
    const key = sortSet(vars).join(', ');
    let id = ids[key];
    if (id === undefined) {
      id = String.fromCharCode(BASE + partitionIdSequence++);
      ids[key] = id;
    }
    return id;
  };

  // Maps a partition's identifier to the variables in the partition.
  const partitionIdInverse: StringMap = {};

  // Maps a language match variable to the set of partitions it covers.
  const variableToPartitionIds: MapSet = {};

  // Maps each region to the partition it belongs to.
  const regionToPartition: MapSet = {};

  // Maps all UN M.49 macro regions to their contained partitions.
  const macroRegionToPartitions: MapSet = {};

  // Maps a variable to a partition identifier
  const partitionIds: StringMap = {};

  // Maps a region to the variables that match it. For example, the
  // country "US" would match the variables [$enUS, $americas, $!cnsar, $!maghreb].
  const regionToVariables: MapSet = {};

  // Maps the partition identifier to the set of regions it contains.
  const partitionToRegions: MapSet = {};

  // All world countries
  const allCountries = territoryContainment['001'];

  // Populate the regionToVariables map.
  Object.keys(matchVariables).sort().forEach(variable => {

    // List of countries that match this variable.
    const countries = matchVariables[variable].sort();

    // List of countries that match the variable's inverse.
    const inverse = new Set<string>(allCountries);

    // Map each country to the variables it matches, and remove the
    // country from the inverse.
    countries.forEach((country: string) => {
      mapSet(regionToVariables, country, variable);
      inverse.delete(country);
    });

    // Map each country to the inverse variable it matches.
    const inverseVar = '$!' + variable.substring(1);
    sortSet(inverse).forEach(country => {
      mapSet(regionToVariables, country, inverseVar);
    });
  });

  // Map the variables to a partition. As of CLDR v32 this
  // splits the world into 6 partitions, with each country belonging
  // to a single partition.
  Object.keys(regionToVariables).sort().forEach(country => {
    const vars = regionToVariables[country];
    const partitionId = getPartitionId(partitionIds, vars);

    mapSet(partitionToRegions, partitionId, country);
    mapSet(regionToPartition, country, partitionId);
    vars.forEach(v => {
      mapSet(variableToPartitionIds, v, partitionId);
    });
  });

  // Map each UN M.49 macro region to one or more partitions.
  Object.keys(territoryContainment).sort().forEach(macro => {
    territoryContainment[macro].forEach((country: string) => {
      const vars = regionToVariables[country];
      const partitionId = getPartitionId(partitionIds, vars);
      mapSet(macroRegionToPartitions, macro, partitionId);
    });
  });

  // Create an inverse mapping of partition id -> variables.
  Object.keys(partitionIds).forEach(k => partitionIdInverse[k] = partitionIds[k]);

  let table = '# Generated by @phensley/cldr-compiler\n\n';
  Object.keys(partitionIdInverse).sort().forEach(vars => {
    const id = partitionIdInverse[vars];
    table += `${id} -> ${vars}\n`;
  });
  table += '\n';
  Object.keys(macroRegionToPartitions).sort().forEach(macro => {
    const partition = sortSet(macroRegionToPartitions[macro]).join(', ');
    table += `${macro}  [${partition}]\n`;
  });
  table += '\n';
  Object.keys(regionToPartition).sort().forEach(region => {
    const partition = sortSet(regionToPartition[region]).join(', ');
    table += `${region}  [${partition}]\n`;
  });

  // Return resulting sets.
  return {
    variables: variableToPartitionIds,
    macroRegions: macroRegionToPartitions,
    regions: regionToPartition,
    table,
  };
};

const encode = (ms: MapSet): string => Object.keys(ms).map(k =>
    `${k}:${sortSet(ms[k]).join('')}`)
    .join('|');

export const getPartition = (data: any): Code[] => {
  const { /* variables, */ macroRegions, regions, table } = buildPartitions(data);

  let code = HEADER;
  let str = '';

  // NOTE: the variables are only used during code generation
  // str = encode(variables);
  // code += NOLINT_MAXLINE;
  // code += `export const variables = '${str}';\n\n`;

  str = encode(regions);
  code += NOLINT_MAXLINE;
  code += `export const regions = '${str}';\n\n`;

  str = encode(macroRegions);
  code += NOLINT_MAXLINE;
  code += `export const macroRegions = '${str}';\n`;

  return [
    Code.core(['locale', 'autogen.partition.ts'], code),
    Code.top(['notes', 'language-partition-table.txt'], table)
  ];
};
