#!/usr/bin/env python

import calendar, json, os, sys
from collections import namedtuple
from datetime import datetime, timedelta
from subprocess import Popen, PIPE

ROOT = os.path.dirname(os.path.abspath(__file__))
ZICROOT = os.path.join(ROOT, 'temp', 'zicout')
ZDUMPPATH = os.path.join(ROOT, 'temp', 'zdump.txt')

Zone = namedtuple('Zone', 'name, offset, until, dst, abbr')

def create():
    if os.path.exists(ZDUMPPATH):
        return
    out = open(ZDUMPPATH, 'w')
    for root, dirs, names in os.walk(ZICROOT):
        for name in names:
            path = os.path.join(root, name)
            zone = os.path.relpath(path, ZICROOT)
            proc = Popen(['zdump', '-v', zone], cwd=ZICROOT, stdout=out)
            proc.communicate()

def is_dupe(z1, z2):
    return z1 and z2 and z1.name == z2.name and z1.offset == z2.offset and z1.abbr == z2.abbr

def parse():
    fmt = '%b %d %H:%M:%S %Y'
    prev = None
    res = []
    for i, line in enumerate(open(ZDUMPPATH)):
        parts = line.strip().split()
        if len(parts) != 15:
            continue
        name = parts[0]

        # slice and decode fields
        raw_utc = ' '.join(parts[2:6])
        raw_loc = ' '.join(parts[9:13])
        _utc = datetime.strptime(raw_utc, fmt)
        _loc = datetime.strptime(raw_loc, fmt)
        utc = calendar.timegm(_utc.timetuple())
        loc = calendar.timegm(_loc.timetuple())

        # construct a zone object
        offset = (utc - loc) / 60
        until = utc
        dst = int(parts[14].replace('isdst=', ''))
        abbr = parts[13]

        curr = Zone(name, offset, until, dst, abbr)

        # group output by zone name
        if prev is None:
            res = [curr]
        elif prev.name != curr.name:
            yield res
            res = [curr]
        else:
            res.append(curr)
        prev = curr

    # yield last list of zones
    yield res

def process():
    for zones in parse():
        # remove duplicate abbr/offset entries
        keep = []
        for z in zones:
            if keep and (keep[-1].abbr == z.abbr and keep[-1].offset == z.offset):
                continue
            keep.append(z)

        # remove negative untils except the first.
        idx = 0
        for i, z in enumerate(keep):
            if z.until >= 0:
                idx = i
                break
        if idx > 0:
            idx -= 1
        yield keep[idx:]

def indexed(vals):
    s = 0
    m = {}
    res = []
    index = []
    for v in vals:
        i = m.get(v)
        if i is None:
            i = s
            m[v] = i
            res.append(v)
            s += 1
        index.append(i)
    return res, index

def deltas(nums):
    # return the deltas for an array of numbers
    p = None
    r = []
    for n in nums:
        if p is None:
            p = n
            r.append(n)
            continue
        r.append(n - p)
        #r.append(None if n is None else n - p)
        p = n
    return r

def main():
    create()
    out = open(os.path.join(ROOT, 'temp', 'tzdata.json'), 'w')
    out.write('[')
    for i, zones in enumerate(process()):
        if i > 0:
            out.write(',\n')

        name = zones[0].name
        offsets = indexed([z.offset for z in zones])
        untils = deltas([z.until for z in zones])
        dsts = [z.dst for z in zones]

        out.write(json.dumps([
            name,
            offsets,
            untils,
            dsts
        ]))

    out.write(']')

if __name__ == '__main__':
    main()

